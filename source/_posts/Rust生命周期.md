---
title: Rust生命周期
tags:
  - 生命周期
categories:
  - Rust
excerpt: rust生命周期的简单介绍
thumbnail: https://pan.mwm.moe/f/vEqc9/12.WEBP
cover: https://t.mwm.moe/pc
sticky: 1
date: 2024-01-08 09:50:02
---

## 生命周期知识点
1. 生命周期标记并不会改变任何引用的实际作用域。在通过函数签名指定生命周期参数时，我们并没有改变传入引用或返回真实引用的真实生命周期，而是告诉编译器当不满足此约束条件时，就拒绝编译通过。
2. 不需要显式标注生命周期的三种规则
  - 每一个引用参数都会获得独自的生命周期
  - 若只有一个输入生命周期(函数参数中只有一个引用类型), 那么该生命周期会被赋给所有的输出生命周期
  - 若存在多个生命周期，且其中一个是`&self`或`&mut self`，则`&self`的生命周期被赋给所有的输出生命周期

## NLL(Non-Lexical Lifetime)
  引用的生命周期正常来说应该从借用开始一直持续到作用域结束。但在1.31版本后，引用的生命周期从借用处开始，一直持续到最后一次使用的地方。

## 再借用
```rust
fn main() {
    let mut p = Point { x: 0, y: 0 };
    let r = &mut p;
    // reborrow! 此时对`r`的再借用不会导致跟上面的借用冲突
    let rr: &Point = &*r;

    // 再借用`rr`最后一次使用发生在这里，在它的生命周期中，我们并没有使用原来的借用`r`，因此不会报错
    println!("{:?}", rr);

    // 再借用结束后，才去使用原来的借用`r`
    r.move_to(10, 10);
    println!("{:?}", r);
}
```
**注意：** 可变引用`r`和不可变引用`rr`同时存在不报错的原因是，`rr`并不是对`p`的不可变引用，而是对`r`的再借用，因此不会破会借用规则。 对于再借用，在`rr`的生命周期内，不能再使用原来的借用`r`。

